1.为什么计算机启动最开始的时候执行的是BIOS代码而不是操作系统自身的代码？

2.为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有把所有需要加载的扇区都加载？

3.为什么BIOS把bootsect加载到0x07c00，而不是0x00000？加载后又马上挪到0x90000处，是何道理？为什么不一次加载到位？

4.bootsect、setup、head程序之间是怎么衔接的？给出代码证据。

5.setup程序里的cli是为了什么？

6.setup程序的最后是jmpi 0,8 为什么这个8不能简单的当作阿拉伯数字8看待？

7.打开A20和打开pe究竟是什么关系，保护模式不就是32位的吗？为什么还要打开A20？有必要吗？

8.Linux是用C语言写的，为什么没有从main函数开始，而是先运行3个汇编程序，道理何在？

9.为什么不用call，而是用ret“调用”main函数？画出调用路线图，给出代码证据。

10.保护模式的“保护”体现在哪里？

11.特权级的目的和意义是什么？

12.在setup程序里曾经设置过一次gdt，为什么在head程序中将其废弃，又重新设置了一个？为什么折腾两次，而不是一次搞好？

13.用户进程自己设计一套LDT表，并与GDT挂接，是否可行，为什么？

14.进程0的task_struct、内核栈、用户栈在哪？给出代码证据。

15.进程0创建进程1时，为进程1建立了自己的task_struct、内核栈，第一个页表，分别位于物理内存16MB的顶端倒数第一页、第二页。请问，这个了页究竟占用的是谁的线性地址空间，内核、进程0、进程1、还是没有占用任何线性地址空间（直接从物理地址分配）？说明理由并给出代码证据。

16.假设：经过一段时间的运行，操作系统中已经有5个进程在运行，且内核分别为进程4、进程5分别创建了第一个页表，这两个页表在谁的线性地址空间？用图表示这两个页表在线性地址空间和物理地址空间的映射关系。

17.进程0开始创建进程1，调用了fork（），跟踪代码时我们发现，fork代码执行了两次，第一次，跳过init（）直接执行了for(;;) pause()，第二次执行fork代码后，执行了init（）。奇怪的是，我们在代码中并没有看见向后的goto语句，也没有看到循环语句，是什么原因导致反复执行？请说明理由，并给出代码证据。

18.copy_process函数的参数最后五项是：long eip,long cs,long eflags,long esp,long ss。查看栈结构确实有这五个参数，奇怪的是其他参数的压栈代码都能找得到，确找不到这五个参数的压栈代码，反汇编代码中也查不到，请解释原因。

19.为什么static inline _syscall0(type,name)中需要加上关键字inline？

20.根据代码详细说明copy_process函数的所有参数是如何形成的？

21.根据代码详细分析，进程0如何根据调度第一次切换到进程1的。

22.内核的线性地址空间是如何分页的？画出从0x000000开始的7个页（包括页目录表、页表所在页）的挂接关系图，就是页目录表的前四个页目录项、第一个个页表的前7个页表项指向什么位置？给出代码证据。

23.用文字和图说明中断描述符表是如何初始化的，可以举例说明（比如：set_trap_gate(0,&divide_error)），并给出代码证据。

24.进程0 fork进程1之前，为什么先要调用move_to_user_mode()？用的是什么方法？解释其中的道理。

25.进程0创建进程1时调用copy_process函数，在其中直接、间接调用了两次get_free_page函数，在物理内存中获得了两个页，分别用作什么？是怎么设置的？给出代码证据。

26.在IA-32中，有大约20多个指令是只能在0特权级下使用，其他的指令，比如cli，并没有这个约定。奇怪的是，在Linux0.11中，在3特权级的进程代码并不能使用cli指令，会报特权级错误，这是为什么？请解释并给出代码证据。

27.根据代码详细分析操作系统是如何获得一个空闲页的。

28、用户进程自己设计一套LDT表，并与GDT挂接，是否可行，为什么？

29、保护模式、分页下，线性地址到物理地址的转化过程是什么？

30、详细分析进程调度的全过程。考虑所有可能（signal、alarm除外）

31、内核和普通用户进程并不在一个线性地址空间内，为什么仍然能够访问普通用户进程的页面？

32、wait_on_buffer函数中为什么不用if（）而是用while（）？

33、copy_mem（）和copy_page_tables（）在第一次调用时是如何运行的？

34、缺页中断是如何产生的，页写保护中断是如何产生的，操作系统是如何处理的？

35、为什么要设计缓冲区，有什么好处？

36、操作系统如何利用buffer_head中的 b_data，b_blocknr，b_dev，b_uptodate，b_dirt，b_count，b_lock，b_wait管理缓冲块的？
37、操作系统如何利用b_uptodate保证缓冲块数据的正确性？new_block (int dev)函数新申请一个缓冲块后，并没有读盘，b_uptodate却被置1，是否会引起数据混乱？详细分析理由。




